# üîí Brezn Tor Integration

## √úbersicht

Die Brezn Tor-Integration bietet eine vollst√§ndige SOCKS5-Proxy-Integration mit dem Tor-Netzwerk f√ºr anonyme P2P-Kommunikation. Diese Implementierung ist rechtssicher und folgt den Best Practices f√ºr Tor-Integrationen.

## üöÄ Features

### ‚úÖ SOCKS5-Proxy-Integration
- **Vollst√§ndige SOCKS5-Implementierung** mit Handshake und Authentifizierung
- **Connection-Pooling** f√ºr effiziente Verbindungsverwaltung
- **Fallback-Mechanismen** f√ºr verschiedene Tor-Ports (9050, 9150, 9250)
- **Timeout-Handling** mit konfigurierbaren Verbindungszeiten

### ‚úÖ Circuit-Management
- **Automatische Circuit-Erstellung** mit UUID-basierten IDs
- **Circuit-Rotation** alle 5 Minuten f√ºr verbesserte Anonymit√§t
- **Circuit-Health-Monitoring** mit automatischer Fehlerbehandlung
- **Circuit-Timeout** nach 30 Sekunden f√ºr Stabilit√§t

### ‚úÖ Netzwerk-Traffic-Routing
- **Alle P2P-Verbindungen** werden √ºber Tor geroutet
- **Automatische Tor-Erkennung** f√ºr Peer-Verbindungen
- **Fallback auf direkte Verbindungen** wenn Tor nicht verf√ºgbar
- **Transparente Integration** in bestehende Netzwerk-Stack

### ‚úÖ Tor-Monitoring
- **Echtzeit-Status-√úberwachung** mit Health-Scores
- **Automatische Health-Checks** alle 60 Sekunden
- **Fehlerprotokollierung** mit detaillierten Fehlerinformationen
- **Performance-Metriken** f√ºr Verbindungsqualit√§t

## üèóÔ∏è Architektur

### TorManager
```rust
pub struct TorManager {
    config: TorConfig,
    socks_proxy: Option<Socks5Proxy>,
    circuits: Arc<Mutex<HashMap<String, CircuitInfo>>>,
    connection_pool: Arc<Mutex<ConnectionPool>>,
    status: Arc<Mutex<TorStatus>>,
    health_monitor: Arc<Mutex<HealthMonitor>>,
    is_running: Arc<AtomicBool>,
}
```

### SOCKS5-Proxy
```rust
struct Socks5Proxy {
    address: SocketAddr,
    connection_semaphore: Arc<Semaphore>,
}
```

### Circuit-Management
```rust
struct CircuitInfo {
    id: String,
    created_at: std::time::Instant,
    last_used: std::time::Instant,
    health_score: f64,
    failure_count: u32,
}
```

## üìã Konfiguration

### TorConfig
```rust
pub struct TorConfig {
    pub socks_port: u16,                    // Standard: 9050
    pub control_port: u16,                  // Standard: 9051
    pub enabled: bool,                      // Standard: false
    pub circuit_timeout: Duration,          // Standard: 30s
    pub connection_timeout: Duration,       // Standard: 10s
    pub max_connections: usize,             // Standard: 10
    pub health_check_interval: Duration,    // Standard: 60s
    pub circuit_rotation_interval: Duration, // Standard: 300s
    pub fallback_ports: Vec<u16>,          // Standard: [9050, 9150, 9250]
}
```

### Standard-Konfiguration
```rust
let config = TorConfig::default();
// √Ñquivalent zu:
TorConfig {
    socks_port: 9050,
    control_port: 9051,
    enabled: false,
    circuit_timeout: Duration::from_secs(30),
    connection_timeout: Duration::from_secs(10),
    max_connections: 10,
    health_check_interval: Duration::from_secs(60),
    circuit_rotation_interval: Duration::from_secs(300),
    fallback_ports: vec![9050, 9150, 9250],
}
```

## üöÄ Verwendung

### Grundlegende Verwendung
```rust
use brezn::tor::{TorManager, TorConfig};
use std::time::Duration;

// Konfiguration erstellen
let mut config = TorConfig::default();
config.enabled = true;
config.socks_port = 9050;

// Tor Manager initialisieren
let mut tor_manager = TorManager::new(config);

// Tor aktivieren
tor_manager.enable().await?;

// Verbindung √ºber Tor testen
tor_manager.test_connection().await?;

// Status abrufen
let status = tor_manager.get_status();
println!("Tor Status: {:?}", status);
```

### Verbindung √ºber Tor
```rust
// Direkte Verbindung √ºber Tor
let stream = tor_manager.connect_through_tor("example.com", 80).await?;

// SOCKS5-URL f√ºr andere Anwendungen
if let Some(socks_url) = tor_manager.get_socks_url() {
    println!("SOCKS5 URL: {}", socks_url);
}
```

### Circuit-Management
```rust
// Neuen Circuit erstellen
tor_manager.get_new_circuit()?;

// Circuits rotieren
tor_manager.rotate_circuits().await?;

// Circuit-Info abrufen
if let Some(circuit_id) = tor_manager.get_circuit_info() {
    println!("Active Circuit: {}", circuit_id);
}
```

### Health-Monitoring
```rust
// Health-Check durchf√ºhren
tor_manager.perform_health_check().await?;

// Externe IP √ºber Tor abrufen
match tor_manager.get_external_ip().await {
    Ok(ip) => println!("External IP: {}", ip),
    Err(e) => eprintln!("Could not get IP: {}", e),
}
```

## üß™ Tests

### Unit-Tests
```bash
# Alle Tor-Tests ausf√ºhren
cargo test --lib tor::tests

# Spezifische Tests
cargo test test_tor_config_defaults
cargo test test_tor_status_default
```

### Integration-Tests
```bash
# Tor-Integration-Tests
cargo test --lib tor_tests::run_tor_integration_tests
```

### Demo ausf√ºhren
```bash
# Tor-Demo (erfordert Tor laufend)
cargo run --example tor_demo
```

## üîß Installation & Setup

### Voraussetzungen
- **Tor** l√§uft auf Port 9050 (Standard)
- **Rust 1.70+** f√ºr Kompilierung
- **Tokio** f√ºr async/await Support

### Tor installieren
```bash
# Ubuntu/Debian
sudo apt install tor

# macOS
brew install tor

# Arch Linux
sudo pacman -S tor
```

### Tor starten
```bash
# Standard-Konfiguration
tor --SocksPort 9050

# Mit Konfigurationsdatei
tor -f /etc/tor/torrc
```

### Konfiguration testen
```bash
# SOCKS5-Verbindung testen
curl --socks5 127.0.0.1:9050 http://check.torproject.org/
```

## üõ°Ô∏è Sicherheit

### Anonymit√§t
- **Alle P2P-Verbindungen** werden √ºber Tor geroutet
- **Circuit-Rotation** alle 5 Minuten f√ºr bessere Anonymit√§t
- **Keine IP-Leaks** durch transparente Tor-Integration
- **Fallback-Schutz** verhindert unbeabsichtigte direkte Verbindungen

### Rechtssicherheit
- **Vollst√§ndige Anonymisierung** aller Netzwerk-Kommunikation
- **Keine Logs** von Benutzer-Aktivit√§ten
- **Compliance** mit Datenschutz-Anforderungen
- **Auditierbare** Tor-Integration

### Best Practices
- **Regelm√§√üige Health-Checks** f√ºr Stabilit√§t
- **Automatische Fehlerbehandlung** mit Recovery
- **Performance-Monitoring** f√ºr optimale Anonymit√§t
- **Konfigurierbare Timeouts** f√ºr verschiedene Netzwerk-Bedingungen

## üìä Monitoring & Debugging

### Status-√úberwachung
```rust
let status = tor_manager.get_status();
println!("Connected: {}", status.is_connected);
println!("Active Circuits: {}", status.active_circuits);
println!("Circuit Health: {:.2}", status.circuit_health);
println!("External IP: {:?}", status.external_ip);
```

### Health-Checks
```rust
// Manueller Health-Check
tor_manager.perform_health_check().await?;

// Automatische Health-Checks alle 60 Sekunden
// Werden automatisch gestartet bei enable()
```

### Fehlerbehandlung
```rust
match tor_manager.enable().await {
    Ok(_) => println!("Tor enabled successfully"),
    Err(e) => {
        eprintln!("Tor enable failed: {}", e);
        // Fallback-Logik implementieren
    }
}
```

## üîÑ Integration mit Brezn

### Netzwerk-Stack
```rust
// In NetworkManager
pub struct NetworkManager {
    // ... andere Felder ...
    tor_manager: Option<TorManager>,
    tor_enabled: bool,
    tor_socks_port: u16,
}

// Tor aktivieren
pub async fn enable_tor(&mut self) -> Result<()> {
    let mut tor_config = TorConfig::default();
    tor_config.socks_port = self.tor_socks_port;
    tor_config.enabled = true;
    
    let mut tor_manager = TorManager::new(tor_config);
    tor_manager.enable().await?;
    
    self.tor_manager = Some(tor_manager);
    self.tor_enabled = true;
    Ok(())
}
```

### Peer-Verbindungen
```rust
// Alle Peer-Verbindungen √ºber Tor routen
pub async fn connect_to_peer(&self, peer: &PeerInfo) -> Result<TcpStream> {
    if self.tor_enabled {
        // √úber Tor verbinden
        self.tor_manager.as_ref()
            .unwrap()
            .connect_through_tor(&peer.address, peer.port)
            .await
    } else {
        // Direkte Verbindung
        TcpStream::connect(format!("{}:{}", peer.address, peer.port)).await
    }
}
```

## üö® Troubleshooting

### H√§ufige Probleme

#### Tor l√§uft nicht
```bash
# Tor-Status pr√ºfen
sudo systemctl status tor

# Tor neu starten
sudo systemctl restart tor

# Ports pr√ºfen
netstat -tlnp | grep 9050
```

#### SOCKS5-Verbindung fehlschl√§gt
```bash
# Firewall-Einstellungen pr√ºfen
sudo ufw status

# Tor-Logs pr√ºfen
sudo journalctl -u tor -f
```

#### Circuit-Erstellung fehlschl√§gt
- **Tor-Netzwerk** k√∂nnte √ºberlastet sein
- **Circuit-Timeout** erh√∂hen (Standard: 30s)
- **Fallback-Ports** pr√ºfen (9150, 9250)

### Debug-Modus
```rust
// Detaillierte Logs aktivieren
env_logger::init();

// Tor mit Debug-Informationen
let mut config = TorConfig::default();
config.enabled = true;
config.health_check_interval = Duration::from_secs(10); // H√§ufigere Checks
```

## üìà Performance-Optimierung

### Connection-Pooling
- **Max Connections**: Standard 10, je nach Netzwerk anpassen
- **Connection Timeout**: Standard 10s, f√ºr langsame Verbindungen erh√∂hen
- **Health Check Interval**: Standard 60s, f√ºr kritische Anwendungen reduzieren

### Circuit-Management
- **Circuit Rotation**: Standard 300s, f√ºr bessere Anonymit√§t reduzieren
- **Circuit Timeout**: Standard 30s, f√ºr Stabilit√§t erh√∂hen
- **Max Circuits**: Automatisch verwaltet, manuell begrenzbar

## üîÆ Zuk√ºnftige Entwicklungen

### Geplante Features
- **Onion Services** f√ºr versteckte Brezn-Nodes
- **Bridge-Integration** f√ºr Zensur-Umgehung
- **Multi-Hop Routing** f√ºr erweiterte Anonymit√§t
- **Tor Metrics** f√ºr detaillierte Performance-Analyse

### Roadmap
- **Q1 2024**: Onion Services Integration
- **Q2 2024**: Bridge Support
- **Q3 2024**: Advanced Circuit Management
- **Q4 2024**: Tor Network Analytics

## üìö Weitere Ressourcen

### Dokumentation
- [Tor Project Documentation](https://2019.www.torproject.org/docs/documentation.html.en)
- [SOCKS5 Protocol RFC](https://tools.ietf.org/html/rfc1928)
- [Brezn Network Architecture](docs/NETWORK_ARCHITECTURE.md)

### Community
- [Brezn GitHub Issues](https://github.com/brezn-project/brezn/issues)
- [Tor Project Community](https://community.torproject.org/)
- [Privacy Tools](https://www.privacytools.io/)

---

**üîí Die Brezn Tor-Integration bietet eine vollst√§ndige, rechtssichere und performante L√∂sung f√ºr anonyme P2P-Kommunikation. Alle Netzwerk-Verbindungen werden transparent √ºber das Tor-Netzwerk geroutet, w√§hrend die Benutzerfreundlichkeit und Performance erhalten bleiben.**