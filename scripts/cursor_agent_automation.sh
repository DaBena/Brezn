#!/bin/bash
# ü§ñ Cursor Agent Automation Script - Brezn MVP
# Automatisiert die Feature-Entwicklung mit Cursor AI

set -e

# Farben f√ºr Output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Projekt-Verzeichnis
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
BREZN_DIR="$PROJECT_ROOT/brezn"
DOCS_DIR="$PROJECT_ROOT/docs"

echo -e "${BLUE}ü§ñ Cursor Agent Automation - Brezn MVP${NC}"
echo -e "${BLUE}==========================================${NC}\n"

# Git Protection Setup pr√ºfen
check_git_protection() {
    echo -e "${YELLOW}üîí Pr√ºfe Git Protection Setup...${NC}"
    
    local email=$(git config user.email)
    local name=$(git config user.name)
    
    if [ "$email" != "brezn-dev@noreply.github.com" ]; then
        echo -e "${RED}‚ùå Git Email nicht korrekt konfiguriert!${NC}"
        echo -e "${YELLOW}F√ºhre setup_git_protection.sh aus...${NC}"
        
        if [ -f "$PROJECT_ROOT/scripts/setup_git_protection.sh" ]; then
            bash "$PROJECT_ROOT/scripts/setup_git_protection.sh"
        else
            echo -e "${RED}‚ùå setup_git_protection.sh nicht gefunden!${NC}"
            exit 1
        fi
    else
        echo -e "${GREEN}‚úÖ Git Protection aktiv${NC}"
    fi
}

# MVP Status analysieren
analyze_mvp_status() {
    echo -e "\n${YELLOW}üìä Analysiere MVP Status...${NC}"
    
    if [ -f "$DOCS_DIR/PROJECT_STATUS_ACTUAL.md" ]; then
        # MVP Fortschritt extrahieren
        local progress=$(grep -oP 'MVP-Fortschritt:\s*\K\d+' "$DOCS_DIR/PROJECT_STATUS_ACTUAL.md" | head -1)
        echo -e "${GREEN}‚úÖ MVP-Fortschritt: ${progress}%${NC}"
        
        # N√§chstes Feature bestimmen
        if [ "$progress" -lt 50 ]; then
            NEXT_FEATURE="p2p-peer-discovery"
            PRIORITY="HIGH"
        elif [ "$progress" -lt 70 ]; then
            NEXT_FEATURE="tor-integration"
            PRIORITY="MEDIUM"
        else
            NEXT_FEATURE="qr-code-implementation"
            PRIORITY="LOW"
        fi
        
        echo -e "${GREEN}üéØ N√§chstes Feature: ${NEXT_FEATURE} (Priorit√§t: ${PRIORITY})${NC}"
    else
        echo -e "${RED}‚ùå PROJECT_STATUS_ACTUAL.md nicht gefunden!${NC}"
        exit 1
    fi
}

# Feature Branch erstellen
create_feature_branch() {
    echo -e "\n${YELLOW}üåø Erstelle Feature Branch...${NC}"
    
    local branch_name="feature/auto-${NEXT_FEATURE}-$(date +%Y%m%d-%H%M)"
    
    # Pr√ºfe ob Branch bereits existiert
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        echo -e "${YELLOW}Branch existiert bereits, verwende bestehenden...${NC}"
    else
        git checkout -b "$branch_name"
        echo -e "${GREEN}‚úÖ Feature Branch erstellt: $branch_name${NC}"
    fi
    
    FEATURE_BRANCH="$branch_name"
}

# Cursor Agent Prompts generieren
generate_cursor_prompts() {
    echo -e "\n${YELLOW}üìù Generiere Cursor Agent Prompts...${NC}"
    
    case "$NEXT_FEATURE" in
        "p2p-peer-discovery")
            cat > "$PROJECT_ROOT/.cursor_prompt_p2p.md" << 'EOF'
# üéØ Implementiere P2P Peer-Discovery

Analysiere `brezn/src/network.rs` und `brezn/src/discovery.rs`.

## Aufgaben:
1. Ersetze alle Platzhalter-Implementierungen
2. Implementiere UDP-Broadcast f√ºr Peer-Discovery
3. F√ºge Peer-Registry mit Heartbeat-System hinzu
4. Erstelle Tests f√ºr Multi-Peer-Konnektivit√§t

## Anforderungen:
- Verwende Tokio f√ºr async Netzwerk-Operationen
- Implementiere proper Error Handling (kein unwrap!)
- F√ºge Logging mit log crate hinzu
- Dokumentiere alle √∂ffentlichen Funktionen

## Code-Beispiel f√ºr UDP-Broadcast:
```rust
use tokio::net::UdpSocket;
use std::net::{Ipv4Addr, SocketAddr};

pub async fn broadcast_discovery() -> Result<()> {
    let socket = UdpSocket::bind("0.0.0.0:0").await?;
    socket.set_broadcast(true)?;
    // Implementierung hier...
}
```
EOF
            ;;
            
        "tor-integration")
            cat > "$PROJECT_ROOT/.cursor_prompt_tor.md" << 'EOF'
# üîí Implementiere Tor-Integration

Analysiere `brezn/src/tor.rs` und erweitere die SOCKS5-Integration.

## Aufgaben:
1. Implementiere vollst√§ndige SOCKS5-Proxy-Verbindung
2. F√ºge Circuit-Management hinzu
3. Teste anonymes Routing
4. Integriere mit P2P-Netzwerk

## Anforderungen:
- SOCKS5 Protokoll korrekt implementieren
- Tor-Verbindung mit Retry-Logic
- Fehlerbehandlung f√ºr Netzwerkfehler
- Performance-Monitoring

## SOCKS5 Handshake:
```rust
// Version 5, 1 Auth method, No auth
let handshake = vec![0x05, 0x01, 0x00];
stream.write_all(&handshake).await?;
```
EOF
            ;;
            
        "qr-code-implementation")
            cat > "$PROJECT_ROOT/.cursor_prompt_qr.md" << 'EOF'
# üì± Implementiere QR-Code-System

Analysiere `brezn/src/discovery.rs` und implementiere QR-Code-Funktionalit√§t.

## Aufgaben:
1. QR-Code-Generierung f√ºr Peer-Daten
2. QR-Code-Parsing und Validierung
3. Peer-Join √ºber QR-Code
4. Cross-Platform-Tests

## Anforderungen:
- Verwende qrcode crate
- JSON-Serialisierung der Peer-Daten
- Zeitbasierte G√ºltigkeit (1 Stunde)
- Fehlerbehandlung f√ºr ung√ºltige QR-Codes

## Datenstruktur:
```rust
#[derive(Serialize, Deserialize)]
struct JoinData {
    node_id: String,
    public_key: String,
    address: String,
    port: u16,
    timestamp: u64,
}
```
EOF
            ;;
    esac
    
    echo -e "${GREEN}‚úÖ Cursor Prompt erstellt: .cursor_prompt_${NEXT_FEATURE}.md${NC}"
}

# Tests ausf√ºhren
run_tests() {
    echo -e "\n${YELLOW}üß™ F√ºhre Tests aus...${NC}"
    
    cd "$BREZN_DIR"
    
    if cargo test --quiet; then
        echo -e "${GREEN}‚úÖ Alle Tests bestanden${NC}"
        return 0
    else
        echo -e "${RED}‚ùå Tests fehlgeschlagen${NC}"
        return 1
    fi
}

# Code formatieren
format_code() {
    echo -e "\n${YELLOW}üé® Formatiere Code...${NC}"
    
    cd "$BREZN_DIR"
    
    cargo fmt
    echo -e "${GREEN}‚úÖ Code formatiert${NC}"
    
    # Clippy laufen lassen
    if cargo clippy -- -D warnings 2>/dev/null; then
        echo -e "${GREEN}‚úÖ Clippy-Checks bestanden${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Clippy Warnungen gefunden${NC}"
    fi
}

# Status aktualisieren
update_status() {
    echo -e "\n${YELLOW}üìä Aktualisiere Projektstatus...${NC}"
    
    # Hier w√ºrde normalerweise PROJECT_STATUS_ACTUAL.md aktualisiert werden
    echo -e "${GREEN}‚úÖ Status w√ºrde aktualisiert (im echten Workflow)${NC}"
}

# Hauptprogramm
main() {
    echo -e "${BLUE}Start: $(date)${NC}\n"
    
    # 1. Git Protection pr√ºfen
    check_git_protection
    
    # 2. MVP Status analysieren
    analyze_mvp_status
    
    # 3. Feature Branch erstellen
    create_feature_branch
    
    # 4. Cursor Prompts generieren
    generate_cursor_prompts
    
    echo -e "\n${GREEN}========================================${NC}"
    echo -e "${GREEN}üéØ Cursor Agent kann jetzt starten!${NC}"
    echo -e "${GREEN}========================================${NC}\n"
    
    echo -e "${YELLOW}üìã N√§chste Schritte:${NC}"
    echo -e "1. √ñffne Cursor im Projekt-Verzeichnis"
    echo -e "2. Lade den generierten Prompt: ${BLUE}.cursor_prompt_${NEXT_FEATURE}.md${NC}"
    echo -e "3. Lasse Cursor das Feature implementieren"
    echo -e "4. F√ºhre dieses Script erneut aus f√ºr Tests und Formatierung"
    echo -e "\n${YELLOW}üí° Tipp: Nutze Cursor's AI f√ºr beste Ergebnisse!${NC}"
    
    # Optional: Warte auf Benutzer-Input
    read -p "$(echo -e '\n${YELLOW}Feature implementiert? Tests ausf√ºhren? (y/n): ${NC}')" -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # 5. Tests ausf√ºhren
        if run_tests; then
            # 6. Code formatieren
            format_code
            
            # 7. Status aktualisieren
            update_status
            
            echo -e "\n${GREEN}üéâ Feature-Entwicklung abgeschlossen!${NC}"
            echo -e "${GREEN}Branch: $FEATURE_BRANCH${NC}"
            echo -e "${YELLOW}Erstelle jetzt einen Pull Request!${NC}"
        else
            echo -e "\n${RED}‚ùå Bitte behebe die Test-Fehler first!${NC}"
        fi
    fi
    
    echo -e "\n${BLUE}Ende: $(date)${NC}"
}

# Script ausf√ºhren
main "$@"